<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class EmailAddressSource - Person Data Generator</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script src="./js/jquery.js"></script>
<script src="./js/darkfish.js"></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link">Object
  
</div>

    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-domain_has_mx_record-3F">::domain_has_mx_record?</a>
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-i-random_domain">#random_domain</a>
    
    <li ><a href="#method-i-random_username">#random_username</a>
    
    <li ><a href="#method-i-record">#record</a>
    
    <li ><a href="#method-i-record_from_name">#record_from_name</a>
    
    <li ><a href="#method-i-records">#records</a>
    
    <li ><a href="#method-i-records_as_xml">#records_as_xml</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-EmailAddressSource">
  <h1 id="class-EmailAddressSource" class="class">
    class EmailAddressSource
  </h1>

  <section class="description">
    
<p>Class to generate random email addresses for a person.</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
      
        <dt id="DefaultRandomSldConsonants">DefaultRandomSldConsonants
        
        <dd><p>Consonants to be used for constructing 2nd level domain parts at random,
i.e. to replace &#39;c&#39; place holders. Skipping some that do not look
good in readable words.</p>
        
      
        <dt id="DefaultRandomSldLetters">DefaultRandomSldLetters
        
        <dd><p>Letters to be used for constructing 2nd level domain parts at random, i.e.
to replace &#39;l&#39; place holders. Mainly used in acronyms.</p>
        
      
        <dt id="DefaultRandomSldVowels">DefaultRandomSldVowels
        
        <dd><p>Vowels to be used for constructing 2nd level domain parts at random.</p>
        
      
        <dt id="DefaultWeightedRandomSldPatterns">DefaultWeightedRandomSldPatterns
        
        <dd><p>Patterns that will be used to generate second level domain parts at random.
The characters in these patterns are as follows:</p>
<ul><li>
<p>l: Letter - any character in EmailAddressSource::DefaultLetters</p>
</li><li>
<p>c: Consonant - any character in EmailAddressSource::DefaultConsonants</p>
</li><li>
<p>v: Vowel - any character in EmailAddressSource::DefaultVowels</p>
</li><li>
<p>s: Same letter - repeat the letter before this one.</p>
</li></ul>
        
      
        <dt id="RealDomains">RealDomains
        
        <dd><p>Some popular email domains that do exist. They will considered if the a
real domain is requested.</p>
        
      
        <dt id="TLDs">TLDs
        
        <dd><p>Top level domains for creating random second level domains.</p>
        
      
        <dt id="UsernamePartSeparators">UsernamePartSeparators
        
        <dd><p>Characters that typically separate elements of the username portion (what
is before the @-sign)  in an email address. Quantity of each character in
this Array tries to represent its populatity.</p>
        
      
        <dt id="UsernameTemplates">UsernameTemplates
        
        <dd><p>ERB template Strings to be used for composing the username portions of
email addresses. A template String is randomly chosen by the respective
method. The name_part_separator is choosen dynamically once per mail
address.</p>
        
      
      </dl>
    </section>
    

    
    <section class="attribute-method-details" class="method-section">
      <header>
        <h3>Attributes</h3>
      </header>

      
      <div id="attribute-i-name_source" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">name_source</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>The username part of email addresses is based on a real name. While the <a
href="EmailAddressSource.html#method-i-record_from_name">#record_from_name</a>
method accepts this real name (or <a href="Name.html">Name</a> object) as a
parameter, it is also possible to generate email addresses (EmailAddress
objects) without providing a real name with <a
href="EmailAddressSource.html#method-i-record">#record</a>. This will
generate a <a href="NameSource.html">NameSource</a> instance to pick real
names from and save it as this EmailAddressSource&#39;s <a
href="EmailAddressSource.html#attribute-i-name_source">#name_source</a>
attribute. (Note that this will only get populated once it is needed.)</p>
        
        </div>
      </div>
      
      <div id="attribute-i-random_sld_patterns" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">random_sld_patterns</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>Patterns that are used to generate a random top level domain pattern.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-skip_mx_test" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">skip_mx_test</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>If generated domain names should be tested for an MX record. When setting
this to &#39;false&#39; it might happen that a generated email domain has,
by coincidence an MX service running. In that case the same issue described
for a true @use_real_domains flag applies.</p>
        
        </div>
      </div>
      
      <div id="attribute-i-use_real_domains" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">use_real_domains</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        <p>If this is set to true the domains are taken from the <a
href="EmailAddressSource.html#RealDomains">RealDomains</a> Array. Note that
when triggering emails to such domains you might end up in the mail box of
a real user. If not you still bother the respective mail servers which is
bad &#39;netiquette&#39;, thus please use real domains (set <a
href="EmailAddressSource.html#attribute-i-use_real_domains">#use_real_domains</a>
to true) only in exceptional cases.</p>
        
        </div>
      </div>
      
    </section>
    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-domain_has_mx_record-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">domain_has_mx_record?</span><span
            class="method-args">( domain )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Check if, by co-incidence, a (random) domain is a real email domain, i.e.
has an MX record.</p>
          
          

          
          <div class="method-source-code" id="domain_has_mx_record-3F-source">
            <pre><span class="ruby-comment"># File email.rb, line 251</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">domain_has_mx_record?</span>( <span class="ruby-identifier">domain</span> )
  <span class="ruby-identifier">mx</span> = []
  <span class="ruby-constant">Resolv</span><span class="ruby-operator">::</span><span class="ruby-constant">DNS</span>.<span class="ruby-identifier">open</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">dns</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">mx</span> = <span class="ruby-identifier">dns</span>.<span class="ruby-identifier">getresources</span>(<span class="ruby-identifier">domain</span>, <span class="ruby-constant">Resolv</span><span class="ruby-operator">::</span><span class="ruby-constant">DNS</span><span class="ruby-operator">::</span><span class="ruby-constant">Resource</span><span class="ruby-operator">::</span><span class="ruby-constant">IN</span><span class="ruby-operator">::</span><span class="ruby-constant">MX</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">mx</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">true</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">( real_domains = false, skip_mx_test = false )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Constructor. Setup a new email address generator. The argument tells if
generated email addresses should show domain parts from existing domains,
or be completely random and not available as Internet email domains (have
MX records).</p>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File email.rb, line 132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>( <span class="ruby-identifier">real_domains</span> = <span class="ruby-keyword">false</span>, <span class="ruby-identifier">skip_mx_test</span> = <span class="ruby-keyword">false</span> )
  <span class="ruby-ivar">@use_real_domains</span> = <span class="ruby-identifier">real_domains</span>
  <span class="ruby-ivar">@skip_mx_test</span> = <span class="ruby-identifier">skip_mx_test</span>
  <span class="ruby-ivar">@random_sld_patterns</span> = <span class="ruby-constant">DefaultWeightedRandomSldPatterns</span>
  <span class="ruby-ivar">@random_sld_letters</span> = <span class="ruby-constant">DefaultRandomSldLetters</span>
  <span class="ruby-ivar">@random_sld_consonants</span> = <span class="ruby-constant">DefaultRandomSldConsonants</span>
  <span class="ruby-ivar">@random_sld_vowels</span> = <span class="ruby-constant">DefaultRandomSldVowels</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-random_domain" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">random_domain</span><span
            class="method-args">( )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Generates a random domain. Depending on the value of this instances
@use_real_domain property this is taken from a pre-defined list of email
domains, or composed from a sequence of random letters. In that case a DNS
lookup for the MX servers is performed to make sure that the domain is not
an existing MX domain and thereby make sure we do not randomly generate an
existing person&#39;s email address.</p>
          
          

          
          <div class="method-source-code" id="random_domain-source">
            <pre><span class="ruby-comment"># File email.rb, line 212</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">random_domain</span>( )
  <span class="ruby-keyword">if</span> ( <span class="ruby-ivar">@use_real_domains</span> )
    <span class="ruby-comment"># This is the only one where we want to return a domain that</span>
    <span class="ruby-comment"># has an MX record!</span>
    <span class="ruby-keyword">return</span>( <span class="ruby-constant">RealDomains</span>[<span class="ruby-identifier">rand</span>(<span class="ruby-constant">RealDomains</span>.<span class="ruby-identifier">length</span>)] )
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">domain</span> = <span class="ruby-string">&#39;&#39;</span>
    <span class="ruby-identifier">no_mx_or_skip</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-comment"># letters = { &#39;v&#39; =&gt; &#39;aeiou&#39;, &#39;c&#39; =&gt; &#39;bcdfghjklmnpqrstvwxyz&#39; } </span>
    <span class="ruby-comment"># Removed some not so nice looking consonants:</span>
    <span class="ruby-identifier">letters</span> = { <span class="ruby-string">&#39;v&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;aeiou&#39;</span>, <span class="ruby-string">&#39;c&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&#39;bcdfghklmnprstwz&#39;</span> } 
    <span class="ruby-keyword">until</span>( <span class="ruby-identifier">no_mx_or_skip</span> )
      <span class="ruby-identifier">random_string</span> = <span class="ruby-string">&#39;&#39;</span>
      <span class="ruby-identifier">last_char</span> = <span class="ruby-string">&#39;&#39;</span>
      <span class="ruby-identifier">pattern</span> = <span class="ruby-identifier">random_sld_patterns</span>.<span class="ruby-identifier">sample</span>
      <span class="ruby-identifier">pattern</span>.<span class="ruby-identifier">each_char</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">l_or_v_or_c</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">new_char</span> = <span class="ruby-keyword">case</span> <span class="ruby-identifier">l_or_v_or_c</span>
          <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;l&#39;</span> <span class="ruby-keyword">then</span> <span class="ruby-ivar">@random_sld_letters</span>[<span class="ruby-identifier">rand</span>(<span class="ruby-ivar">@random_sld_letters</span>.<span class="ruby-identifier">length</span>)].<span class="ruby-identifier">chr</span>
          <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;c&#39;</span> <span class="ruby-keyword">then</span> <span class="ruby-ivar">@random_sld_consonants</span>[<span class="ruby-identifier">rand</span>(<span class="ruby-ivar">@random_sld_consonants</span>.<span class="ruby-identifier">length</span>)].<span class="ruby-identifier">chr</span>
          <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;v&#39;</span> <span class="ruby-keyword">then</span> <span class="ruby-ivar">@random_sld_vowels</span>[<span class="ruby-identifier">rand</span>(<span class="ruby-ivar">@random_sld_vowels</span>.<span class="ruby-identifier">length</span>)].<span class="ruby-identifier">chr</span>
          <span class="ruby-keyword">when</span> <span class="ruby-string">&#39;s&#39;</span> <span class="ruby-keyword">then</span> <span class="ruby-identifier">last_char</span>
          <span class="ruby-keyword">else</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;Pattern contains a character other than l, v, c, or s!&quot;</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">random_string</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">new_char</span>
        <span class="ruby-identifier">last_char</span> = <span class="ruby-identifier">new_char</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">domain</span> = <span class="ruby-identifier">random_string</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39;.&#39;</span> <span class="ruby-operator">+</span> <span class="ruby-constant">TLDs</span>.<span class="ruby-identifier">sample</span>
      <span class="ruby-comment"># Loop will end (a) we don&#39;t care about MX records or (b) this domain</span>
      <span class="ruby-comment"># does not have an MX record, i.e. when non_mx_domain becomes true:</span>
      <span class="ruby-identifier">no_mx_or_skip</span> = <span class="ruby-ivar">@skip_mx_test</span> <span class="ruby-operator">||</span>
                           ( <span class="ruby-operator">!</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">domain_has_mx_record?</span>(<span class="ruby-identifier">domain</span>) )
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">domain</span> 
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-random_username" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">random_username</span><span
            class="method-args">( givenname_full, surname )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Generate a random username from the givenname and surname (provided as
arguments). Instead of names this accepts any other String (e.g. surname
and town instead of givenname and surname can also make sense).</p>
          
          

          
          <div class="method-source-code" id="random_username-source">
            <pre><span class="ruby-comment"># File email.rb, line 196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">random_username</span>( <span class="ruby-identifier">givenname_full</span>, <span class="ruby-identifier">surname</span> )
  <span class="ruby-identifier">name_part_separator</span> =
    <span class="ruby-constant">UsernamePartSeparators</span>[<span class="ruby-identifier">rand</span>(<span class="ruby-constant">UsernamePartSeparators</span>.<span class="ruby-identifier">length</span>)]
  <span class="ruby-identifier">givenname</span> = <span class="ruby-identifier">givenname_full</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp">/\s/</span>).<span class="ruby-identifier">join</span>(<span class="ruby-identifier">name_part_separator</span>)
  <span class="ruby-identifier">erb_template</span> = <span class="ruby-constant">ERB</span>.<span class="ruby-identifier">new</span>( <span class="ruby-constant">UsernameTemplates</span>[<span class="ruby-identifier">rand</span>(<span class="ruby-constant">UsernameTemplates</span>.<span class="ruby-identifier">length</span>)] )
  <span class="ruby-identifier">erb_template</span>.<span class="ruby-identifier">result</span>( <span class="ruby-identifier">binding</span> )
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-record" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">record</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns and email address as an <a
href="EmailAddress.html">EmailAddress</a> instance. The name (Name
instance) on which the email addres is based is taken from this
EmailAddressSource&#39;s @name_source. In case it does not have a
@name_source yet this gets created automatically.</p>
          
          

          
          <div class="method-source-code" id="record-source">
            <pre><span class="ruby-comment"># File email.rb, line 166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">record</span>()
  <span class="ruby-keyword">unless</span> ( <span class="ruby-ivar">@name_source</span> )
    <span class="ruby-ivar">@name_source</span> = <span class="ruby-constant">NameSource</span>.<span class="ruby-identifier">new</span>()
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">record_from_name</span>( <span class="ruby-ivar">@name_source</span>.<span class="ruby-identifier">record</span>() )
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-record_from_name" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">record_from_name</span><span
            class="method-args">( name, surname = nil )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns an email address as an <a href="EmailAddress.html">EmailAddress</a>
instance, from which the username part is composed by (parts of) the
givenname and the surname. Both givenname and surname are taken as
arguments. Instead of the two names the method also accepts one argument.
This should be a <a href="Name.html">Name</a> instance (or of any class
that has a givenname and a surname method).</p>
          
          

          
          <div class="method-source-code" id="record_from_name-source">
            <pre><span class="ruby-comment"># File email.rb, line 147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">record_from_name</span>( <span class="ruby-identifier">name</span>, <span class="ruby-identifier">surname</span> = <span class="ruby-keyword">nil</span> )
  <span class="ruby-keyword">if</span> ( <span class="ruby-identifier">name</span>.<span class="ruby-identifier">kind_of?</span>( <span class="ruby-constant">Name</span> ) )
    <span class="ruby-identifier">givenname</span> = <span class="ruby-identifier">name</span>.<span class="ruby-identifier">givenname</span>
    <span class="ruby-identifier">surname</span> = <span class="ruby-identifier">name</span>.<span class="ruby-identifier">surname</span> <span class="ruby-operator">||</span> <span class="ruby-string">&#39;&#39;</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">givenname</span> = <span class="ruby-identifier">name</span>
    <span class="ruby-identifier">surname</span> = <span class="ruby-identifier">surname</span> <span class="ruby-operator">||</span> <span class="ruby-string">&#39;&#39;</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">username</span> = <span class="ruby-identifier">random_username</span>( <span class="ruby-identifier">givenname</span>.<span class="ruby-identifier">to_ascii</span>(),
                              <span class="ruby-identifier">surname</span>.<span class="ruby-identifier">to_ascii</span>() )
  <span class="ruby-identifier">domain</span> = <span class="ruby-identifier">random_domain</span>()
  <span class="ruby-constant">EmailAddress</span>.<span class="ruby-identifier">new</span>( <span class="ruby-identifier">username</span>, <span class="ruby-identifier">domain</span> )
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-records" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">records</span><span
            class="method-args">( quantity = 1 )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Return an Array of random email addresses (EmailAddress objects).</p>
          
          

          
          <div class="method-source-code" id="records-source">
            <pre><span class="ruby-comment"># File email.rb, line 174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">records</span>( <span class="ruby-identifier">quantity</span> = <span class="ruby-value">1</span> )
  <span class="ruby-identifier">email_addresses</span> = []
  <span class="ruby-identifier">quantity</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">email_addresses</span>.<span class="ruby-identifier">push</span>( <span class="ruby-keyword">self</span>.<span class="ruby-identifier">record</span>() )
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">email_addresses</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-records_as_xml" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">records_as_xml</span><span
            class="method-args">( quantity = 1 )</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Return XML data containing one root element &#39;emailing&#39; and children
as &#39;address&#39; elements.</p>
          
          

          
          <div class="method-source-code" id="records_as_xml-source">
            <pre><span class="ruby-comment"># File email.rb, line 184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">records_as_xml</span>( <span class="ruby-identifier">quantity</span> = <span class="ruby-value">1</span> )
  <span class="ruby-identifier">addr_arr</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">records</span>(<span class="ruby-identifier">quantity</span>)
  <span class="ruby-constant">XmlSimple</span>.<span class="ruby-identifier">xml_out</span>( { <span class="ruby-value">:address</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">addr_arr</span> },
                     { <span class="ruby-value">:NoAttr=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>, <span class="ruby-value">:RootName=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">:emailing</span>,
                       <span class="ruby-value">:XmlDeclaration=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span> } )
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

